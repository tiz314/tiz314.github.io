---
layout: post
title: "Keeping FreeRTOS on Schedule: A Periodic Task Layer with Monitoring and Simulation"
permalink: /freertosptl
---

FreeRTOS Periodic Task Layer (PTL) is a modular library whose goal is to introduce *easy Periodic Task Management* and *Monitoring* inside the Vanilla FreeRTOS Kernel. 

You will be able to specify a set of payloads to iteratively execute in a periodic manner, together with periods, deadlines and a policy to be applied in case of period overruns. 
A Monitoring Framework will enable you to oversee the timeline of events occurring in the system. 
Task deadline misses will be logged by the monitoring system, whilst period overruns will trigger the specified policy on the task, and be logged as well.
Furthermore, the library integrates a simulation system to easily track and compare your results with how your tasks should behave in theory.


## Table of Contents
- [What's New](#whats-new)
- [How to Use It](#how-to-use-it)
    - [Enabling Periodic Task Management](#enabling-periodic-task-management)
    - [Enabling Monitoring](#enabling-monitoring)
    - [Enabling Simulation](#enabling-simulation)

## What's New
The library is structured as a modular set of components, shipped as a patched version of the FreeRTOS system. 
The patch is located exclusively in `task.c`, `task.h`, `projdefs.h`, as well as `FreeRTOS.h` and `FreeRTOSConfig.h` for configurations, plus a newly added component: `monitor.c`, with the associated `monitor.h`. 
Finally `monitor_hooks.h` is created to extend the already existing set of trace hooks to handle the monitoring of the newly defined events (e.g., deadline miss, task completion, overruns, ...).


## How to Use It
You can decide to enable the periodic task management tool, the monitoring mechanisms (potentially with the addition of the simulation system) or both. 

### Enabling Periodic Task Management
To enable it, you must set the `configUSE_OVERRUN_POLICIES` flag to 1 in `FreeRTOSConfig.h`: 
```c
#define configUSE_OVERRUN_POLICIES 1
```
Once done, you will be able to define the set of periodic task directly in the main function as follows: 
```c
PeriodicTaskDescriptor_t xTasks[] = {
        {
            pxTaskCode,            /* Pointer to task payload. */
            "Task Name",           /* Name of task. */
            uxStackDepth,          /* Stack depth. */     
            pvParameters,          /* Function parameters. */ 
            uxPriority,            /* Task priority. */
            pxHandle,              /* Handle. */
            xPeriod,               /* Task period. */
            xDeadline,             /* Task deadline. */
            xOffset,               /* Starting delay. */
            ePolicy                /* Local policy for period overruns. */
        }
    };

SchedulerConfig_t xSchedConf = {
    .pxTaskSet = xTasks,           /* The task set. */
    .uxTasksNum = 1,               /* Number of periodic tasks. */
    .eGlobalPolicy = eSkipPolicy,  /* Global period overrun policy. */
};

xTaskInitPeriodicTasks(&xSchedConf);
```
`xPeriod`, `xDeadline` and `xOffset` are measured in ticks. `ePolicy` is applied whenever a period overrun occurs, which happens when the iteration of the task is not completed before the next release occurs. For the `ePolicy` argument, you can choose among: 
- `eSkipPolicy`: Skip this new release, and leave the last iteration to complete.
- `eKillPolicy`: Immediately kill the running instance and restart the task with the new release.
- `eCatchupPolicy`: If previous overruns occurred, once the task has finished, skip the eventual delay and immediately start a new iteration of the task. The effect stacks.
- `eNonePolicy`: No specific policy. If a task has `eNonePolicy` and a global policy is set in the scheduler configuration, the global policy will be applied to it. If both a task and the scheduler configuration have `eNonePolicy`, no policy will be enforced.

If the policies to be applied globally and locally to the task are different, the local one prevails.

### Enabling Monitoring
To enable the monitoring framework, firstly include the new `monitor.c` file in the source files to be compiled. In the Makefile: 
```Makefile
SOURCE_FILES += $(KERNEL_DIR)/monitor.c
```
Then, enable the component via `FreeRTOSConfig.h`:
```c
#define configUSE_TRACE_FACILITY 1
#define configUSE_MONITORING 1
```
This will expand the already existing hook-based tracing infrastructure with additional trace hooks for the events to be logged. 

Once done, a circular log of events (named `xTraceLogs`) of length `configLOG_LENGTH` (100 by default, but customizable by redefining it in `FreeRTOSConfig.h`) will be filled with information related to periodic tasks such as application of policies and deadline misses, and additionally on task switch in and finish.

The last two events are logged only if the following flag is set to 0 in `FreeRTOSConfig.h`:
```c
#define configONLY_LOG_ERRORS 0
```

#### Monitoring Hooks Configuration
In order to visualize the logs, the user can define a custom function that must be associated to the `vPrintSysLogs()` monitoring hook.
This can be done directly in `FreeRTOSConfig.h`. An example follows.

```c
/* Function signature. */
void vPrintLogs( void * pxLogs, void * uxLen );

/* Associating monitoring hook to custom function. */
#define vPrintSysLogs()   vPrintLogs( xTraceLogs, ( void * ) configLOG_LENGTH )
```
This ensures that the user has the freedom to do with the logs what they desire, including visualizing them in a hardware-dependent way.

**Note**: The macro `configRUN_DURATION`, defaulting to 1000 but redefinable in `FreeRTOSConfig.h`, indicates how long the task set will run for before being interrupted by a higher priority task (`prvSupervisor`), generating logs and calling `vPrintSysLogs()`.

### Enabling Simulation
The simulation system can be activated by setting the following flag to 1 in `FreeRTOSConfig.h`:
```c
#define configUSE_TESTING 1
```
If the flag is enabled, once the task set has run for the time period indicated by `configRUN_DURATION`, a simulation on the same task set will be run for the same period of time, generating logs.
Note that `configUSE_MONITORING` must be set to 1 for the simulation to work.
The logs are contained in `xSimLogs`, a circular log structure of length `configLOG_LENGTH`.

In order for the simulation to run correctly, the `SchedulerConfig_t` structure that is passed to `xTaskInitPeriodicTask` features an additional field, `pxWcets`.
The same example as before, but adapted to the simulation system, follows:
```c
PeriodicTaskDescriptor_t xTasks[] = {
        {
            pxTaskCode,
            "Task Name",      
            uxStackDepth,
            pvParameters,
            uxPriority,
            pxHandle,
            xPeriod,
            xDeadline,
            xOffset,
            ePolicy
        }
    };

SchedulerConfig_t xSchedConf = {
    .pxTaskSet = xTasks,
    .uxTasksNum = 1,
    .eGlobalPolicy = eSkipPolicy,
    .pxWcets = { 300 }             /* Worst Case Execution Time for each task. */
};

xInitPeriodicTasks(&xSchedConf);
```

#### Simulation Hooks Configuration

Similarly to monitoring logs, simulation logs can be visualized by the user by defining a custom function that must be associated to the `vPrintSimLogs()` simulation hook.
This can be done in `FreeRTOSConfig.h` as in the following example.
```c
/* Function signature. */
void vPrintLogs( void * pxLogs, void * uxLen );

/* Associating simulation hook to custom function. */
#define vPrintSimLogs()  		     vPrintLogs( xSimLogs, ( void * ) LOG_LENGTH )
```

#### Simulation execution
The simulated trace generation is handled by `vMonitorSimulateTrace` automatically called by the supervisor function if the testing module is enabled. The generated trace log is compared line by line with the real trace log generated during the previous system execution. The comparison is performed, for each entry, checking the event and the associated task the event is originated from. An overall score is finally returned, as the number of matching entries over the filled log size (matching between empty entries is avoided). 

### Example Usage
An example usage of the Periodic Task Layer with monitoring layer and simulation system active follows. In the main function we find:
```c
static PeriodicTaskDescriptor_t xTaskSet[] = {
    { vBusyWaitingT, "Kill_H", 256, ( void * ) 150, 3, NULL, 10, 10, 0, eKillPolicy },
    { vBusyWaitingT, "Skip_M", 256, ( void * ) 350, 2, NULL, 20, 20, 0, eSkipPolicy },
    { vBusyWaitingT, "Catch_L", 256, ( void * ) 800, 1, NULL, 50, 50, 0, eCatchupPolicy },
    { vBusyWaitingT, "Kill_1", 256, ( void * ) 150, 3, NULL, 10, 10, 0, eKillPolicy },
    { vBusyWaitingT, "Skip_2", 256, ( void * ) 350, 2, NULL, 20, 20, 0, eSkipPolicy },
    { vBusyWaitingT, "Catch_3", 256, ( void * ) 800, 1, NULL, 50, 50, 0, eCatchupPolicy },
    { vBusyWaitingT, "Kill_4", 256, ( void * ) 150, 3, NULL, 10, 10, 0, eKillPolicy },
    { vBusyWaitingT, "Skip_5", 256, ( void * ) 350, 2, NULL, 20, 20, 0, eSkipPolicy },
    { vBusyWaitingT, "Catch_6", 256, ( void * ) 800, 1, NULL, 50, 50, 0, eCatchupPolicy }
};

SchedulerConfig_t xSchedConf = { 
    xTaskSet, 
    9, 
    eNonePolicy, 
    ( TickType_t[] ){ 150, 350, 800, 50, 350, 800, 50, 350, 800 } 
};

xTaskInitPeriodicTasks(&xSchedConf);
```
Where `vBusyWaitingT` performs busy waiting for the period indicated in its parameter. By executing the set for 100 ticks, part of the monitoring log will look like this: 
```c
55 0x20004770 Kill_4 JOB_SWITCHED_IN
56 0x20002be0 Kill_H JOB_SWITCHED_IN
57 0x200039a8 Kill_1 JOB_SWITCHED_IN
58 0x20004770 Kill_4 JOB_SWITCHED_IN
59 0x20002be0 Kill_H JOB_SWITCHED_IN
60 0x20003078 Skip_M DEADLINE_MISS
60 0x20003078 Skip_M PERIOD_OVERRUN_SKIP
60 0x20003e40 Skip_2 DEADLINE_MISS
60 0x20003e40 Skip_2 PERIOD_OVERRUN_SKIP
60 0x20004c08 Skip_5 DEADLINE_MISS
60 0x20004c08 Skip_5 PERIOD_OVERRUN_SKIP
60 0x200039a8 Kill_1 JOB_SWITCHED_IN
61 0x20002be0 Kill_H DEADLINE_MISS
61 0x20002be0 Kill_H PERIOD_OVERRUN_KILL
61 0x200039a8 Kill_1 DEADLINE_MISS
61 0x200039a8 Kill_1 PERIOD_OVERRUN_KILL
61 0x20004770 Kill_4 DEADLINE_MISS
61 0x20004770 Kill_4 PERIOD_OVERRUN_KILL
61 0x200039a8 Kill_1 JOB_SWITCHED_IN
62 0x20004770 Kill_4 JOB_SWITCHED_IN
63 0x20002be0 Kill_H JOB_SWITCHED_IN
...
```
After the initial execution of the timer service and of a high-priority supervisor task, the periodic task set is executed, logging the switch-in of every task, each iteration completion and unexpected events, such as deadlines and period overrun policies applied. 

The source code will be available [here](https://github.com/void-antani-int/FreeRTOS-PTL).